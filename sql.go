package main

import (
	"database/sql"
	"encoding/json"
	"errors"
	_ "github.com/go-sql-driver/mysql"
	"golang.org/x/net/context"
	"log"
)

// SQL retrieves the *sql.DB with the given name or nil.
func SQL(ctx context.Context) *Database {
	db, _ := ctx.Value("db").(*Database)
	if db == nil {
		log.Fatal(errors.New("SQL connection nil"))
	}
	return db
}

// OpenSQL opens a SQL connection and returns a new context or panics.
func openSQL(ctx context.Context, config *Config) context.Context {
	var db Database
	var err error
	db.sql, err = sql.Open("mysql",
		config.SQL.Username+":"+config.SQL.Password+"@tcp("+config.SQL.Address+":"+config.SQL.Port+")/"+config.SQL.Database+"?parseTime=true")
	if err != nil {
		log.Fatal(err)
	}
	err = db.sql.Ping()
	if err != nil {
		log.Fatal(err)
	}
	return context.WithValue(ctx, "db", &db)
}

// CloseSQL closes the specified SQL connection, panciking if Close returns an error.
// CloseSQL will do nothing if the given SQL connection does not exist.
func closeSQL(ctx context.Context) context.Context {
	db := SQL(ctx)
	if db.sql == nil {
		return ctx
	}

	if err := db.sql.Close(); err != nil {
		log.Fatal(err)
	}
	return context.WithValue(ctx, "db", nil)
}

type Database struct {
	sql *sql.DB
}

func (database *Database) UserGet(id string) (User, error) {
	var user User
	stmt, err := database.sql.Prepare("SELECT * FROM users WHERE id = ?")
	if err != nil {
		log.Println("failed to create prepared statement to get user")
		return user, err
	}
	defer stmt.Close()
	err = stmt.QueryRow(id).Scan(&user.ID, &user.Email, &user.Name, &user.ProfilePicture)
	if err != nil {
		log.Println("failed to get user from database")
		return user, err
	}
	return user, nil
}

func (database *Database) UserAdd(newUser User) error {
	stmt, err := database.sql.Prepare("INSERT INTO users(id, email, name, profilepicture) VALUES(?, ?, ?, ?)")
	if err != nil {
		log.Println("failed to create prepared statement to add user")
		return err
	}
	_, err = stmt.Exec(newUser.ID, newUser.Email, newUser.Name, newUser.ProfilePicture)
	if err != nil {
		log.Println("failed to add user to database")
		return err
	}
	log.Printf("Added user %s to database", newUser.ID)
	return nil
}

func (database *Database) UserEdit(user User) error {
	stmt, err := database.sql.Prepare("UPDATE users SET email = ?, name = ?, profilepicture = ? WHERE id = ?")
	if err != nil {
		log.Println("failed to create prepared statement to edit user")
		return err
	}
	_, err = stmt.Exec(user.Email, user.Name, user.ProfilePicture, user.ID)
	if err != nil {
		log.Println("failed to edit user in database")
		return err
	}
	log.Printf("Edited user %s in database", user.ID)
	return nil
}

func (database *Database) UserDelete(id string) error {
	stmt, err := database.sql.Prepare("DELETE FROM users WHERE id = ?")
	if err != nil {
		log.Println("failed to create prepared statement to delete user")
		return err
	}
	_, err = stmt.Exec(id)
	if err != nil {
		log.Println("failed to delete user in database")
		return err
	}
	log.Printf("Deleted user %s in database", id)
	return nil
}

func (database *Database) EntryGet(id string) (Entry, error) {
	var entry Entry
	stmt, err := database.sql.Prepare("SELECT * FROM entries WHERE id = ?")
	if err != nil {
		log.Println("failed to create prepared statement to get entry")
		return entry, err
	}
	defer stmt.Close()
	var marshaledPHPErrors string
	err = stmt.QueryRow(id).Scan(&entry.ID, &entry.File, &entry.Created, &entry.ErrorCount, &marshaledPHPErrors, &entry.UserID)
	if err != nil {
		log.Println("failed to get entry from database")
		return entry, err
	}
	err = json.Unmarshal([]byte(marshaledPHPErrors), &entry.PHPErrors)
	if err != nil {
		log.Println("failed to unmashal phperrors from database")
		return entry, err
	}
	return entry, nil
}

func (database *Database) UserEntriesGet(userid string) ([]Entry, error) {
	var entries []Entry
	stmt, err := database.sql.Prepare("SELECT * FROM entries WHERE userid = ?")
	if err != nil {
		log.Println("failed to create prepared statement to get user entries")
		return nil, err
	}
	defer stmt.Close()
	rows, err := stmt.Query(userid)
	if err != nil {
		log.Println("failed to query for user entries")
		return nil, err
	}
	defer rows.Close()
	for rows.Next() {
		var entry Entry
		var marshaledPHPErrors string
		err = rows.Scan(&entry.ID, &entry.File, &entry.Created, &entry.ErrorCount, &marshaledPHPErrors, &entry.UserID)
		if err != nil {
			log.Println("failed to scan row user entries")
			log.Fatal(err)
		}
		err = json.Unmarshal([]byte(marshaledPHPErrors), &entry.PHPErrors)
		if err != nil {
			log.Println("failed to unmashal phperrors from database")
			return nil, err
		}
		entries = append(entries, entry)
	}
	if err = rows.Err(); err != nil {
		log.Println("rows error with user entries")
		return nil, err
	}
	return entries, nil
}

func (database *Database) EntryAdd(newEntry Entry) error {
	stmt, err := database.sql.Prepare("INSERT INTO entries(id, file, created, errorcount, phperrors, userid) VALUES(?, ?, ?, ?, ?, ?)")
	if err != nil {
		log.Println("failed to create prepared statement to add entry")
		return err
	}
	encodedPHPErrors, err := json.Marshal(newEntry.PHPErrors)
	if err != nil {
		log.Println("failed to marshal phperrors")
		return err
	}
	_, err = stmt.Exec(&newEntry.ID, &newEntry.File, &newEntry.Created, &newEntry.ErrorCount, string(encodedPHPErrors), &newEntry.UserID)
	if err != nil {
		log.Println("failed to add entry to database")
		return err
	}
	log.Printf("Added entry %s to database", newEntry.ID)
	return nil
}

func (database *Database) EntryDelete(id string) error {
	stmt, err := database.sql.Prepare("DELETE FROM entries WHERE id = ?")
	if err != nil {
		log.Println("failed to create prepared statement to delete entry")
		return err
	}
	_, err = stmt.Exec(id)
	if err != nil {
		log.Println("failed to edit entry in database")
		return err
	}
	log.Printf("Deleted entry %s from database", id)
	return nil
}
