package main

import (
	"errors"
	"github.com/gorilla/mux"
	"github.com/satori/go.uuid"
	"golang.org/x/net/context"
	"html/template"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strings"
	"time"
)

type HandlerFuncExtended func(context.Context, http.ResponseWriter, *http.Request)
type HandlerFuncExtendedWithUser func(context.Context, User, http.ResponseWriter, *http.Request)

func withContext(ctx context.Context, handler HandlerFuncExtended) http.HandlerFunc {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		handler(ctx, w, r)
	})
}

func authenticationHandler(ctx context.Context, handler HandlerFuncExtendedWithUser) http.HandlerFunc {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		token, err := r.Cookie("session")
		if err != nil {
			if err == http.ErrNoCookie {
				http.Redirect(w, r, "/login/", http.StatusTemporaryRedirect)
			} else {
				httpErrorHandler(w, r, 400, errors.New("Problem accessing your cookies"))
			}
			return
		}
		if !validUUIDV4(token.Value) {
			http.Redirect(w, r, "/login/", http.StatusTemporaryRedirect)
			return
		}
		userID, err := Redis(ctx, "cookie").Get(token.Value).Result()
		if err != nil {
			http.Redirect(w, r, "/login/", http.StatusTemporaryRedirect)
			return
		}
		user, err := SQL(ctx).UserGet(userID)
		if err != nil {
			http.Redirect(w, r, "/login/", http.StatusTemporaryRedirect)
			return
		}
		Redis(ctx, "cookie").Del(token.Value)
		generateSessionToken(ctx, user.ID, &w)
		handler(ctx, user, w, r)
	})
}

func homePageHandler(ctx context.Context, user User, w http.ResponseWriter, r *http.Request) {
	data := make(map[string]interface{})
	entries, err := SQL(ctx).UserEntriesGet(user.ID)
	if err != nil {
		httpErrorHandler(w, r, 500, nil)
		return
	}
	funcMap := template.FuncMap{"formatTime": formatTime}
	data["Entries"] = entries
	data["User"] = user
	err = renderTemp(w, "home", data, funcMap)
	if err != nil {
		httpErrorHandler(w, r, 500, nil)
		return
	}
}

func loginPageHandler(w http.ResponseWriter, r *http.Request) {
	filePath := "HTMLTemplates/login.html"
	b, err := ioutil.ReadFile(filePath)
	if err != nil {
		log.Printf("Failed to show page: %s", err)
		httpErrorHandler(w, r, 500, nil)
		return
	}
	w.Write(b)
}

func entryCreatePageHandler(ctx context.Context, user User, w http.ResponseWriter, r *http.Request) {
	data := make(map[string]interface{})
	data["User"] = user
	err := renderTemp(w, "entrycreate", data, nil)
	if err != nil {
		httpErrorHandler(w, r, 500, nil)
		return
	}
}

func entryCreateHandler(ctx context.Context, user User, w http.ResponseWriter, r *http.Request) {
	codeFile, codeFileHeader, err := r.FormFile("codefile")
	codeText := r.FormValue("codetext")
	var codeBytes []byte
	if codeText != "" {
		codeBytes = []byte(codeText)
	} else if err == nil {
		if codeFileHeader.Size > 10000000 {
			log.Printf("User %s tried to upload file greater than 10MB", user.ID)
			httpErrorHandler(w, r, 400, errors.New("The code file you selected was over 10MB please pick a smaller file"))
			return
		}
		filenameSplit := strings.Split(codeFileHeader.Filename, ".")
		if len(filenameSplit) < 0 {
			log.Printf("User %s tried to upload file that dosn't have the dot php file extension", user.ID)
			httpErrorHandler(w, r, 400, errors.New("The code file you selected dosn't have the dot php file extension"))
			return
		}
		if filenameSplit[len(filenameSplit)-1] != "php" {
			log.Printf("User %s tried to upload file that dosn't have the dot php file extension", user.ID)
			httpErrorHandler(w, r, 400, errors.New("The code file you selected dosn't have the dot php file extension"))
			return
		}
		codeFileBuff := make([]byte, codeFileHeader.Size)
		codeFile.Read(codeFileBuff)
		if http.DetectContentType(codeFileBuff) != "text/plain; charset=utf-8" {
			log.Printf("User %s tried to upload a file that was non text/plain or wasn't utf-8 encoded", user.ID)
			httpErrorHandler(w, r, 400, errors.New("The code file you selected is not plain text please try again with a diffrent file"))
			return
		}
		codeBytes = codeFileBuff
	} else {
		log.Printf("User %s tried to submit with no code file or code text", user.ID)
		httpErrorHandler(w, r, 400, errors.New("You didnt provide code text or code file. Please select a file or write some code before submitting."))
		return
	}
	entryUUID, err := uuid.NewV4()
	tempPHPFileName := "./TempPHPFileHolder/" + entryUUID.String() + ".php"
	err = ioutil.WriteFile(tempPHPFileName, codeBytes, 0600)
	if err != nil {
		log.Println(err)
		httpErrorHandler(w, r, 500, nil)
		return
	}
	errorCount, phpErrors, err := findErrorInPHPFile(tempPHPFileName)
	if err != nil {
		log.Println(err)
		log.Printf("Failed to remove %s", tempPHPFileName)
		if err != nil {
			log.Println("Failed to remove ")
			httpErrorHandler(w, r, 500, nil)
			return
		}
		httpErrorHandler(w, r, 500, nil)
		return
	}
	phpErrors, err = addPHPErrorDescriptionCommentsToFile(phpErrors, tempPHPFileName)
	if err != nil {
		log.Println(err)
		os.Remove(tempPHPFileName)
		if err != nil {
			log.Printf("Failed to remove %s", tempPHPFileName)
			httpErrorHandler(w, r, 500, nil)
			return
		}
		httpErrorHandler(w, r, 500, nil)
		return
	}
	phpFileWithComments, err := ioutil.ReadFile(tempPHPFileName)
	if err != nil {
		log.Println(err)
		os.Remove(tempPHPFileName)
		if err != nil {
			log.Printf("Failed to remove %s", tempPHPFileName)
			httpErrorHandler(w, r, 500, nil)
			return
		}
		httpErrorHandler(w, r, 500, nil)
		return
	}
	entry := Entry{
		ID:         entryUUID.String(),
		File:       phpFileWithComments,
		Created:    time.Now(),
		ErrorCount: errorCount,
		PHPErrors:  phpErrors,
		UserID:     user.ID,
	}
	SQL(ctx).EntryAdd(entry)
	os.Remove(tempPHPFileName)
	if err != nil {
		log.Printf("Failed to remove %s", tempPHPFileName)
		httpErrorHandler(w, r, 500, nil)
		return
	}
	http.Redirect(w, r, "/entry/"+entryUUID.String()+"/", http.StatusSeeOther)
}

func entryPageHandler(ctx context.Context, user User, w http.ResponseWriter, r *http.Request) {
	URLVars := mux.Vars(r)
	entryID := URLVars["entryID"]
	entry, err := SQL(ctx).EntryGet(entryID)
	if err != nil {
		httpErrorHandler(w, r, 400, errors.New("Entry dosn't exist or there was an error getting the entry"))
		return
	}
	if entry.UserID != user.ID {
		httpErrorHandler(w, r, 400, errors.New("Owned by a diffrent user"))
		log.Printf("User %s tried to access entry from user %s", user.ID, entry.UserID)
		return
	}

	data := make(map[string]interface{})
	data["Entry"] = entry
	data["User"] = user
	data["Code"] = string(entry.File)
	err = renderTemp(w, "entry", data, nil)
	if err != nil {
		httpErrorHandler(w, r, 500, nil)
		return
	}
}

func entryDeleteHandler(ctx context.Context, user User, w http.ResponseWriter, r *http.Request) {
	URLVars := mux.Vars(r)
	entryID := URLVars["entryID"]
	entry, err := SQL(ctx).EntryGet(entryID)
	if err != nil {
		httpErrorHandler(w, r, 400, errors.New("Entry dosn't exist or there was an error getting the entry"))
		return
	}
	if entry.UserID != user.ID {
		httpErrorHandler(w, r, 400, errors.New("Owned by a diffrent user"))
		log.Printf("User %s tried to delete entry from user %s", user.ID, entry.UserID)
		return
	}
	err = SQL(ctx).EntryDelete(entryID)
	if err != nil {
		log.Printf("Failed to delete entry %s", entryID)
		httpErrorHandler(w, r, 500, nil)
		return
	}
	http.Redirect(w, r, "/", http.StatusSeeOther)
}

func userSettingPageHandler(ctx context.Context, user User, w http.ResponseWriter, r *http.Request) {
	data := make(map[string]interface{})
	data["User"] = user
	err := renderTemp(w, "settings", data, nil)
	if err != nil {
		httpErrorHandler(w, r, 500, nil)
		return
	}
}

func userDeleteHandler(ctx context.Context, user User, w http.ResponseWriter, r *http.Request) {
	err := SQL(ctx).UserDelete(user.ID)
	if err != nil {
		log.Printf("Failed to delete user %s", user.ID)
		httpErrorHandler(w, r, 500, nil)
		return
	}
	http.Redirect(w, r, "/", http.StatusSeeOther)
}

func formatTime(time time.Time) string {
	return time.Format("2/01/06 15:04:05")
}
