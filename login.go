package main

import (
	"database/sql"
	"encoding/json"
	"errors"
	"github.com/go-redis/redis"
	"github.com/google/go-cmp/cmp"
	"github.com/satori/go.uuid"
	"golang.org/x/net/context"
	"golang.org/x/oauth2"
	"golang.org/x/oauth2/google"
	"io/ioutil"
	"log"
	"net/http"
	"time"
)

type OauthHandler struct {
	Config *oauth2.Config
}

func NewOauthHandler(config *Config) (OauthHandler, error) {
	var scopes []string
	for _, scope := range config.Oauth.Scopes {
		scopes = append(scopes, "https://www.googleapis.com/auth/"+scope)
	}
	var oauth OauthHandler
	oauth.Config = &oauth2.Config{
		ClientID:     config.Oauth.ClientID,
		ClientSecret: config.Oauth.ClientSecret,
		RedirectURL:  config.Oauth.RedirectURL,
		Scopes:       scopes,
		Endpoint:     google.Endpoint,
	}
	return oauth, nil
}

func (oauth *OauthHandler) loginRedirect(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	stateUUID, err := uuid.NewV4()
	tempTokenUUID, err := uuid.NewV4()
	if err != nil {
		log.Println("Critical error couldn't generate UUIDV4 for oauth state")
		httpErrorHandler(w, r, 500, nil)
		return
	}
	state := stateUUID.String()
	tempToken := tempTokenUUID.String()
	expireTimeToken := time.Now().Add(5 * time.Minute)
	stateCookie := http.Cookie{Name: "TempToken", Value: tempToken, Expires: expireTimeToken, Path: "/login/auth/", HttpOnly: true, Secure: true}
	http.SetCookie(w, &stateCookie)
	url := oauth.Config.AuthCodeURL(state)
	Redis(ctx, "state").Set(tempToken, state, time.Until(expireTimeToken))
	http.Redirect(w, r, url, http.StatusTemporaryRedirect)
}

func (oauth *OauthHandler) authResponse(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	userTempTokenCookie, err := r.Cookie("TempToken")
	if err != nil {
		log.Println("User login timed out")
		httpErrorHandler(w, r, 400, errors.New("Login timed out please try again"))
		return
	}
	userTempToken := userTempTokenCookie.Value
	googleState := r.FormValue("state")
	if err != nil || !validUUIDV4(userTempToken) || !validUUIDV4(googleState) || googleState == "" {
		log.Println("Somthing in the response was invalid")
		httpErrorHandler(w, r, 400, errors.New("Something went wrong with login try again"))
		return
	}

	userState, err := Redis(ctx, "state").Get(userTempToken).Result()
	if err == redis.Nil {
		log.Println("State didnt exist")
		httpErrorHandler(w, r, 500, nil)
		return
	} else if err != nil {
		log.Println("Redis error")
		httpErrorHandler(w, r, 500, nil)
		return
	}

	if googleState != userState {
		log.Println("state was not the same")
		httpErrorHandler(w, r, 400, errors.New("Somthing went wrong with your login please try again"))
		return
	}

	token, err := oauth.Config.Exchange(oauth2.NoContext, r.FormValue("code"))
	if err != nil {
		log.Println("something went wrong with the token")
		httpErrorHandler(w, r, 500, nil)
		return
	}
	client := oauth.Config.Client(oauth2.NoContext, token)
	resp, err := client.Get("https://www.googleapis.com/oauth2/v3/userinfo")
	if err != nil {
		log.Println("Somthing when wrong making the request")
		httpErrorHandler(w, r, 500, nil)
		return
	}
	defer resp.Body.Close()
	buffer, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		httpErrorHandler(w, r, 500, nil)
		return
	}

	var user User
	err = json.Unmarshal(buffer, &user)
	if err != nil {
		log.Println("unmarshaling")
		httpErrorHandler(w, r, 500, nil)
		return
	}

	//remove tempkey from redis so it cant be reused
	Redis(ctx, "state").Del(userTempToken)
	userInDatabase, err := SQL(ctx).UserGet(user.ID)
	if err != nil && err != sql.ErrNoRows {
		log.Println("error trying to find out if user is already in database")
		httpErrorHandler(w, r, 500, nil)
		return
	}
	if err == sql.ErrNoRows {
		err = SQL(ctx).UserAdd(user)
		if err != nil {
			httpErrorHandler(w, r, 500, nil)
			return
		}
	} else if !cmp.Equal(userInDatabase, user) {
		err = SQL(ctx).UserEdit(user)
		if err != nil {
			httpErrorHandler(w, r, 500, nil)
			return
		}
	}
	generateSessionToken(ctx, user.ID, &w)
	http.Redirect(w, r, "/", http.StatusTemporaryRedirect)
}

func generateSessionToken(ctx context.Context, id string, w *http.ResponseWriter) {
	tokenUUID, err := uuid.NewV4()
	if err != nil {
		log.Fatalf("Critical error couldn't generate UUIDV4 for oauth state")
		return
	}
	token := tokenUUID.String()
	expireTimeToken := time.Now().Add(5 * time.Minute)
	sessionCookie := http.Cookie{Name: "session", Value: token, Expires: expireTimeToken, Path: "/", HttpOnly: true, Secure: true}
	http.SetCookie(*w, &sessionCookie)
	Redis(ctx, "cookie").Set(token, id, time.Until(expireTimeToken))
	return
}
