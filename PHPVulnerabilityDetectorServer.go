package main

import (
	"errors"
	"github.com/gorilla/mux"
	"golang.org/x/net/context"
	"html/template"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"time"
)

func renderTemp(w http.ResponseWriter, tmpl string, v interface{}, funcMap template.FuncMap) error {
	var err error
	var t *template.Template
	templateName := tmpl + ".html"
	templatePath := "HTMLTemplates/" + tmpl + ".html"
	if funcMap != nil {
		t, err = template.New("").Funcs(funcMap).ParseFiles(templatePath)
	} else {
		t, err = template.ParseFiles(templatePath)
	}
	if err != nil {
		return err
	}
	err = t.ExecuteTemplate(w, templateName, v)
	if err != nil {
		return err
	}
	return nil
}

func httpErrorHandler(w http.ResponseWriter, r *http.Request, status int, errCause error) {
	type Error struct {
		Status        string
		StatusMessage string
		ErrorMessage  string
	}
	var errorPage Error
	w.WriteHeader(status)
	if status == http.StatusNotFound {
		errorPage = Error{"404: Page Not Found", "The page you are looking for dosn't exist or has been removed.", ""}
		log.Printf("The Page %s %s does not exist", r.Host, r.URL.Path)
	} else if status == http.StatusBadRequest {
		errorPage = Error{"400: Bad Request", "The request that was made was invalid.", errCause.Error()}
		log.Printf("The Page %s %s receieved a bad request", r.Host, r.URL.Path)
	} else if status == http.StatusInternalServerError {
		errorPage = Error{"500: Internal Server Error", "An Unrecoverable Error Occured. For more information please contact the system administrator.", ""}
		if errCause != nil {
			errorPage.ErrorMessage = errCause.Error()
			log.Printf("The Page %s %s has an internal server error: %s", r.Host, r.URL.Path, errCause)
		} else {
			errorPage.ErrorMessage = errors.New("Unknown Error").Error()
			log.Printf("The Page %s %s has an internal server error: unknown", r.Host, r.URL.Path)
		}
	}
	err := renderTemp(w, "error", errorPage, nil)
	if err != nil {
		log.Printf("Failed to show error page: %s", err)
	}
}

func notFoundHandler(w http.ResponseWriter, r *http.Request) {
	httpErrorHandler(w, r, 404, nil)
}

func loadHTMLFile(filename string) []byte {
	filePath := "HTMLTemplates/" + filename + ".html"
	b, err := ioutil.ReadFile(filePath)
	if err != nil {
		log.Printf("Failed to show page: %s", err)
		return nil
	}
	return b
}

func main() {
	log.SetOutput(os.Stdout)
	config := LoadConfig("config.yml")
	logFile, err := os.OpenFile(config.Log.Path, os.O_CREATE|os.O_APPEND|os.O_RDWR, 0666)
	if err != nil {
		log.Fatalf("Failed to create/open log file located at %s", config.Log.Path)
		panic(err)
	}
	mw := io.MultiWriter(os.Stdout, logFile)
	log.SetOutput(mw)

	oauthHandler, err := NewOauthHandler(&config)
	if err != nil {
		log.Fatal(err)
	}
	ctx := context.Background()
	ctx = DatabaseNewConnections(ctx, &config)

	//regex warning: gorilla mux regex adds ^ to the start and $ to the end of the regex automatically
	r := mux.NewRouter()
	//home page
	r.HandleFunc("/", authenticationHandler(ctx, homePageHandler)).Methods("GET")
	//login page
	r.HandleFunc("/login/", loginPageHandler).Methods("GET")
	//login page
	r.HandleFunc("/login/google/", withContext(ctx, oauthHandler.loginRedirect)).Methods("GET")
	//login redirect
	r.HandleFunc("/login/auth/", withContext(ctx, oauthHandler.authResponse))
	//user settings page
	r.HandleFunc("/user/", authenticationHandler(ctx, userSettingPageHandler)).Methods("GET")
	//user delete
	r.HandleFunc("/user/delete/", authenticationHandler(ctx, userDeleteHandler)).Methods("GET")
	//entry create page
	r.HandleFunc("/entry/create/", authenticationHandler(ctx, entryCreatePageHandler)).Methods("GET")
	//entry submission
	r.HandleFunc("/entry/create/", authenticationHandler(ctx, entryCreateHandler)).Methods("POST")
	//entry view page
	r.HandleFunc("/entry/{entryID:[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}}/", authenticationHandler(ctx, entryPageHandler)).Methods("GET")
	//entry delete page
	r.HandleFunc("/entry/{entryID:[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}}/delete/", authenticationHandler(ctx, entryDeleteHandler)).Methods("GET")

	r.PathPrefix("/js/").Handler(http.StripPrefix("/js/", http.FileServer(http.Dir("js")))).Methods("GET")
	r.PathPrefix("/css/").Handler(http.StripPrefix("/css/", http.FileServer(http.Dir("css")))).Methods("GET")
	r.PathPrefix("/image/").Handler(http.StripPrefix("/image/", http.FileServer(http.Dir("image")))).Methods("GET")
	r.NotFoundHandler = http.HandlerFunc(notFoundHandler)
	log.Printf("Starting Server")
	srv := &http.Server{
		Handler:      r,
		Addr:         ":" + config.Server.Port,
		WriteTimeout: 15 * time.Second,
		ReadTimeout:  15 * time.Second,
	}
	//redirect http to https
	go http.ListenAndServe(":80", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		http.Redirect(w, r, "https://"+r.Host+r.URL.String(), http.StatusMovedPermanently)
	}))
	srv.ListenAndServeTLS(config.Server.Cert, config.Server.Key)
	//close database connection
	ctx = DatabaseClose(ctx)
}
