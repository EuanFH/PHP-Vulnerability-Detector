package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"os/exec"
	"regexp"
	"strconv"
	"strings"
	"unicode"
)

func findErrorInPHPFile(tempPHPFileName string) (int, []PHPError, error) {
	currentWorkingDirectory, err := os.Getwd()
	if err != nil {
		log.Print(err)
		//log
		return 0, nil, err
	}
	phpStanOutput, err := exec.Command(currentWorkingDirectory+"/phpstan/vendor/bin/phpstan", "analyse", tempPHPFileName).Output()
	if err != nil {
		//program gives wrong error status for some reason
		if err.Error() != "exit status 1" {
			log.Print(err)
			return 0, nil, err
		}
	}
	phpStanOutputLines := strings.Split(string(phpStanOutput), "\n")
	errorCount, phpErrors, err := parsePHPStanOutput(phpStanOutputLines)
	if err != nil {
		log.Println("Problem parsing phpstan: " + err.Error())
		return 0, nil, err
	}
	return errorCount, phpErrors, err
}

func parsePHPStanOutput(phpStanOutputLines []string) (int, []PHPError, error) {
	var phpErrors []PHPError
	stripNonNumbers, err := regexp.Compile("[^0-9]+")
	if err != nil {
		log.Fatal(err)
	}
	errorCount := 0
	var tempPHPError PHPError
	for _, line := range phpStanOutputLines {
		//if line is greater than three chracters continue
		if len([]rune(line)) >= 3 {
			//if its a line for next part of description add it to the description then add it to the slice
			//else if there is a completed phpError add it to the array
			if string([]rune(line)[2]) == " " && tempPHPError.LineNumber != 0 && tempPHPError.Description != "" {
				tempPHPError.Description = tempPHPError.Description + " " + strings.TrimSpace(line)
				phpErrors = append(phpErrors, tempPHPError)
				tempPHPError.LineNumber = 0
				tempPHPError.Description = ""
			} else if tempPHPError.LineNumber != 0 && tempPHPError.Description != "" {
				phpErrors = append(phpErrors, tempPHPError)
				tempPHPError.LineNumber = 0
				tempPHPError.Description = ""
			}
			//gets line of error by checking if the 2 character is a number
			if _, err := strconv.Atoi(string([]rune(line)[2])); err == nil {
				//gets the line number
				if _, err := strconv.Atoi(string([]rune(line)[3])); err == nil {
					tempPHPError.LineNumber, err = strconv.Atoi(string([]rune(line)[2:4]))
					if err != nil {
						return 0, nil, err
					}
				} else {
					tempPHPError.LineNumber, err = strconv.Atoi(string([]rune(line)[2]))
					if err != nil {
						return 0, nil, err
					}
				}
				tempPHPError.Description = strings.TrimSpace(string([]rune(line)[4:]))
			} else if len([]rune(line)) >= 6 && string([]rune(line)[2:7]) == "ERROR" {
				//gets number of errors
				errorCountString := stripNonNumbers.ReplaceAllString(line, "")
				errorCount, err = strconv.Atoi(errorCountString)
				if err != nil {
					return 0, nil, err
				}
			}
		}
	}
	return errorCount, phpErrors, nil
}

func addPHPErrorDescriptionCommentsToFile(phpErrors []PHPError, phpFilePath string) ([]PHPError, error) {
	phpFile, err := os.Open(phpFilePath)
	if err != nil {
		log.Println("Error opening php temp file")
		return nil, err
	}
	var phpFileLines []string
	scanner := bufio.NewScanner(phpFile)
	for scanner.Scan() {
		phpFileLines = append(phpFileLines, scanner.Text())
	}
	if scanner.Err() != nil {
		return nil, err
	}
	phpFile.Close()
	//minuse 1 is to account for how lines start at 1 and slices start at 0
	for i, _ := range phpErrors {
		//special case for error on line 1
		whitespace := keepOnlyWhiteSpaces(phpFileLines[phpErrors[i].LineNumber-1])

		comment := whitespace + "//ERROR: " + phpErrors[i].Description
		phpFileLines = append(phpFileLines[:phpErrors[i].LineNumber-1], append([]string{comment}, phpFileLines[phpErrors[i].LineNumber-1:]...)...)
		for n := i; n < len(phpErrors); n++ {
			phpErrors[n].LineNumber = phpErrors[n].LineNumber + 1
		}
	}
	phpFile, err = os.Create(phpFilePath)
	if err != nil {
		log.Println("Error recreating php temp file")
		return nil, err
	}
	w := bufio.NewWriter(phpFile)
	for _, line := range phpFileLines {
		fmt.Fprintln(w, line)
	}
	w.Flush()
	phpFile.Close()
	return phpErrors, nil
}

func keepOnlyWhiteSpaces(text string) string {
	//can't believe i have to write this go needs a better regex implementation
	var postionWhereWhiteSpaceEnds int
	for i := 0; i < len([]rune(text)); i++ {
		if !unicode.IsSpace([]rune(text)[i]) {
			postionWhereWhiteSpaceEnds = i
			break
		}
	}
	//there is a dollar sign for some reason addon in this is to remove it
	whitespaces := string([]rune(text)[0 : postionWhereWhiteSpaceEnds+1])
	stripNonSpaces, err := regexp.Compile("[^ ]+")
	if err != nil {
		log.Fatal(err)
	}
	return stripNonSpaces.ReplaceAllString(whitespaces, "")
}
