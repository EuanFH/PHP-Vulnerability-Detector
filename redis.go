package main

import (
	"errors"
	"github.com/go-redis/redis"
	"golang.org/x/net/context"
	"log"
)

const (
	cookieDBID = 0
	stateDBID  = 1
)

// Redis retrieves the *redis.Client with the given name or nil.
func Redis(ctx context.Context, name string) *redis.Client {
	var db int
	if name == "cookie" {
		db = cookieDBID
	} else if name == "state" {
		db = stateDBID
	} else {
		return nil
	}
	client, _ := ctx.Value(db).(*redis.Client)
	if client == nil {
		log.Fatal(errors.New("Redis connection is null"))
	}
	return client
}

// OpenRedis opens a Redis connection and returns a new context or panics.
func openRedis(ctx context.Context, config *Config) context.Context {
	cookieClient := redis.NewClient(&redis.Options{
		Addr:     config.Redis.CookieStore.Address + ":" + config.Redis.CookieStore.Port,
		Password: config.Redis.CookieStore.Password,
		DB:       config.Redis.CookieStore.Database,
	})
	stateClient := redis.NewClient(&redis.Options{
		Addr:     config.Redis.StateStore.Address + ":" + config.Redis.StateStore.Port,
		Password: config.Redis.StateStore.Password,
		DB:       config.Redis.StateStore.Database,
	})
	_, err := cookieClient.Ping().Result()
	if err != nil {
		log.Fatal(err)
	}
	_, err = stateClient.Ping().Result()
	if err != nil {
		log.Fatal(err)
	}
	ctx = context.WithValue(ctx, cookieDBID, cookieClient)
	return context.WithValue(ctx, stateDBID, stateClient)
}

// CloseRedisAll closes all open Redis connections and returns a new context without them.
func closeRedisAll(ctx context.Context) context.Context {
	redisDBs := [2]string{"cookie", "state"}
	for _, db := range redisDBs {
		client := Redis(ctx, db)
		if client == nil {
			return ctx
		}

		if err := client.Close(); err != nil {
			log.Fatal(err)
		}
	}
	ctx = context.WithValue(ctx, cookieDBID, nil)
	return context.WithValue(ctx, stateDBID, nil)
}
